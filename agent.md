
### **마사몽 AI 챗봇 2.4 최종 실행 계획서**

-----

#### **1. 프로젝트 목표**

기존 '마사몽 AI 챗봇 2.0'의 RAG 기반 아키텍처를 **'다단계 동적 Tool-Using Agent'** 모델로 확장합니다. \*\*카카오맵(지역), 라이엇 게임즈(게임), Finnhub(해외 주식), 공공데이터포털(국내 주식), 한국수출입은행(환율/금리)\*\*의 무료 API를 연동하여, 사용자의 **복합적인 자연어 질문**에 대해서도 **여러 도구를 순차적으로 사용하는 계획을 스스로 수립**하고 실행하여, 정확한 정보를 제공하는 **고지능 AI 어시스턴트**로 봇을 고도화합니다. 모든 기능은 **무료 API 플랜**의 제약 조건 내에서 안정적으로 동작하도록 설계합니다.

-----

#### **2. 핵심 원칙 및 제약사항 준수**

  * **기존 코드 활용:** `cogs`, `utils`, `database` 구조와 `ai_handler.py` 중심의 AI 처리 로직을 그대로 계승하고 확장합니다.
  * **LLM 모델 고정:** `config.py`에 명시된 `gemini-2.5-flash-lite`(의도 분석용), `gemini-2.5-flash`(답변 생성용) 모델을 변경 없이 사용합니다.
  * **보안 최우선:** 모든 API 키는 `.env` 파일을 통해서만 관리하며, 코드 내에 절대 하드코딩하지 않습니다.
  * **완전 무료 운영:** 각 API의 공식 문서를 기반으로 무료 사용량(Rate Limit)을 명확히 파악하고, 시스템 내에 호출 횟수를 제한하는 안전장치(Throttling)를 구현하여 과금을 원천 차단합니다.
  * **⭐ API 형식 준수:** 모든 API 핸들러(`utils` 폴더)는 각 API의 공식 문서에 명시된 **요청 파라미터와 형식(Request Format)을 엄격하게 준수**하여 개발합니다. 이를 통해 API 호출 오류를 최소화하고 안정적인 데이터 수신을 보장합니다.

-----

#### **3. 최적화 및 토큰 관리 전략**

이 확장 계획은 토큰 오버플로우를 원천적으로 방지하고 효율적인 운영을 보장하기 위해 다음과 같은 최적화 전략을 포함합니다.

  * **⭐ RAG를 통한 문맥 기억 및 후속 질문 처리:** 봇은 전체 대화 기록이 아닌, 사용자의 현재 질문과 **의미적으로 가장 관련성이 높은 과거 대화 몇 개만**을 DB에서 선별(Retrieval)하여 AI에게 전달합니다. 이를 통해 **"아니 광양말고 여수"** 와 같이 생략된 내용이 많은 후속 질문에도, AI가 \*\*"방금 '날씨'에 대해 물었었다"\*\*는 핵심 문맥을 파악하고 정확하게 대응할 수 있게 합니다. 이는 불필요한 토큰 사용을 막는 가장 핵심적인 최적화 전략입니다.
  * **2단계 LLM 호출 분리:**
    1.  **'계획' 단계:** `gemini-2.5-flash-lite` 모델을 사용하여 사용자의 짧은 질문과 도구 목록만으로 \*\*행동 계획(Plan)\*\*을 수립합니다. 이 단계에서는 매우 적은 토큰만 사용됩니다.
    2.  **'답변' 단계:** 외부 API로부터 받은 **정제된 JSON 데이터**를 기반으로 답변을 생성합니다. 두 번째 호출의 프롬프트 또한 간결하게 유지됩니다.
  * **API 결과 데이터 필터링:** 각 `utils` API 핸들러는 외부 API로부터 받은 데이터 중 답변 생성에 **필수적인 정보(예: 현재가, KDA, 장소 이름)만을 추출**하여 Cog에 전달합니다.
  * **간단한 정보 캐싱(Caching):** 자주 요청되지만 잘 변하지 않는 정보(예: '페이커'의 소환사 고유 ID)는 처음 조회 시 메모리에 잠시 저장(캐싱)해두었다가 재사용합니다.

-----

#### **4. API 상세 분석 및 활용 계획**

| API 서비스 | 공식 문서 링크 | 무료 플랜 제공량 | 봇 시스템 제한 설정 | 주요 활용 엔드포인트 및 데이터 |
| :--- | :--- | :--- | :--- | :--- |
| **Riot Games** | [developer.riotgames.com/docs/lol](https://developer.riotgames.com/docs/lol) | 개발 키: 20회/1초, 100회/2분 | 15회/1초, 80회/2분 | **LoL/TFT:** `/summoner/v4/summoners/by-name` (puuid 획득), `/match/v5/matches/by-puuid` (매치 ID 목록), `/match/v5/matches/{matchId}` (상세 전적). **Valorant:** API가 제한적이므로 팀/요원 등 정적 정보 제공 위주로 구현. |
| **Finnhub** | [finnhub.io/docs/api](https://finnhub.io/docs/api) | 분당 60회 | 분당 50회 | **`/quote`** (c: 현재가, d: 변동값, dp: 변동률). **`/company-news`** (headline, summary, url). **⭐반드시 무료 엔드포인트만 사용.** |
| **Kakao Local** | [developers.kakao.com/docs](https://developers.kakao.com/docs/latest/ko/local/dev-guide) | 일일 300,000회 | 일일 250,000회 | **`/v2/local/search/keyword.json`** (documents 배열의 place\_name, road\_address\_name, phone, place\_url). |
| **KRX 주식시세** | [data.go.kr/data/15094808/openapi.do](https://www.data.go.kr/data/15094808/openapi.do) | 일일 10,000회 (일반 한도) | 일일 9,000회 | **`/getStockPriceInfo`** (itmsNm: 종목명, clpr: 종가, vs: 대비, fltRt: 등락률). |
| **한국수출입은행** | [koreaexim.go.kr/ir/HPHKIR019M01](https://www.google.com/search?q=https://www.koreaexim.go.kr/ir/HPHKIR019M01) | 일일 1,000회 | 일일 900회 | **`/exchangeJSON`** (searchdate, cur\_unit: 통화코드, deal\_bas\_r: 매매기준율). |

**※ 중요:** 위 표에 명시된 무료 사용량은 현재 시점의 정보이며, 각 API 제공사의 정책에 따라 언제든지 변경될 수 있습니다. 개발 전 각 API의 공식 문서를 방문하여 최신 무료 사용량 정책을 다시 한번 확인해주세요.

-----

#### **5. 전체 개발 흐름 및 상세 설명**

##### **Step 1: 기반 환경 구축 및 보안 설정**

1. 게)

## 섹션 1: 다단계 에이전트 코어 아키텍처 설계

본 섹션에서는 제안된 '계획 및 실행(Plan-and-Execute)' 모델의 심층적인 아키텍처 분석을 제공합니다. 이는 단순히 고수준의 개념적 설명을 넘어, `ai_handler.py` 모듈을 위한 구체적인 구현 전략, 고급 프롬프트 엔지니어링 기법, 그리고 견고한 제어 흐름을 제시하는 것을 목표로 합니다. 지능적일 뿐만 아니라 신뢰성, 디버깅 용이성, 비용 효율성까지 갖춘 시스템을 구축하는 데 중점을 둡니다.

### 1.1. 계획 단계 마스터링: Gemini를 위한 고급 프롬프트 엔지니어링

이 하위 섹션에서는 `gemini-2.5-flash-lite` 모델을 위한 시스템 프롬프트를 해체하고 강화하는 방안을 다룹니다. 목표는 전체 에이전트 워크플로우의 초석이 되는 JSON 형식의 `plan` 출력 신뢰도를 극대화하는 것입니다.

#### 기존 프롬프트 분석 및 강화 전략

제공된 프롬프트는 도구, 규칙, 예시를 정의함으로써 견고한 기반을 마련하고 있습니다. 특히 LLM을 '생각 엔진'으로 규정하는 '역할 프롬프팅(Role Prompting)' 기법을 효과적으로 사용하고 있습니다.[1] 이 구조를 더욱 정교화하기 위해, Google의 공식 함수 호출(Function Calling) 문서에서 제시하는 설계 원칙을 적용하여 프롬프트의 명확성을 향상시킬 수 있습니다.[2, 3, 4, 5] 프로젝트가 수동 JSON 기반 접근 방식을 사용하더라도, 함수 및 매개변수 설명을 극도로 명확하고 모호하지 않게 만드는 것이 핵심입니다. 도구 설명을 공식적인 `FunctionDeclaration` 객체와 유사하게 구조화하여, 명시적인 매개변수 이름과 타입을 포함시키는 것을 권장합니다 (예: `kakao_place_search(query: string)`).

#### 사고의 연쇄(Chain-of-Thought) 통합

"애플 주식 한화로 얼마야?"와 같은 복합적인 질문을 처리하기 위해, 모델은 암묵적으로 사고의 연쇄(Chain-of-Thought, CoT) 과정을 수행해야 합니다. 현재 프롬프트에 이 추론 과정을 명시적으로 장려하는 지침을 추가함으로써 계획 수립의 정확도를 높일 수 있습니다. 예를 들어, 다음과 같은 지침을 추가할 수 있습니다: *"먼저, 사용자의 최종 목표에 답하기 위해 필요한 정보가 무엇인지 단계별로 생각해. 그 다음, 그 생각의 과정을 `plan` 배열 안에 순차적인 도구 호출 목록으로 변환해."* 이러한 접근 방식은 LLM의 복잡한 추론 능력을 향상시키는 것으로 입증된 CoT 프롬프팅 기법에서 영감을 받았습니다.[1, 6]

#### 모호성 처리 및 엣지 케이스 관리

프롬프트는 일반적인 모호성에 대해 강건해야 합니다. 예를 들어, "삼성 주가 알려줘"와 같은 질문에 대해 모델은 `krx_stock_search`를 올바르게 기본값으로 선택해야 합니다. 특정 회사명이 여러 국가의 주식 시장에 존재할 수 있는 경우를 대비하여, 한국 기업명에 대해서는 KRX 검색을 우선하도록 규칙을 추가해야 합니다. 이러한 세부 규칙은 모델의 예측 불가능성을 줄이고 일관된 행동을 유도하는 데 필수적입니다.

### 1.2. 실행 루프: `ai_handler.py`를 위한 견고한 제어 흐름

이 하위 섹션에서는 '계획 실행기' 로직을 위한 상세한 청사진을 제공합니다. 이는 LLM이 생성한 확률적 계획을 구체적인 행동으로 변환하는 결정론적 코드의 핵심입니다.

#### 상태 관리와 도구 간 데이터 흐름

다단계 실행에서 가장 중요한 과제는 도구 호출 간의 상태를 관리하는 것입니다. "애플 주식 원화 환산" 예시에서, `finnhub_stock_search` 도구의 출력(USD 가격)은 반드시 캡처되어 후속 `exim_exchange_rate` 호출의 입력 매개변수로 사용되어야 합니다. 이를 위해 실행 루프 내에 `context` 딕셔너리 또는 상태 객체를 도입하는 방안을 제안합니다.

```python
# ai_handler.py 내 실행기 로직 예시
context = {}
for step in plan:
    # 동적 디스패치를 통해 적절한 Cog 함수 호출
    result = await execute_tool(step['tool_to_use'], step['parameters'], context)
    # 다음 단계를 위해 결과값을 context에 저장
    if result:
        context.update(result)
```

이 구조는 각 단계의 출력이 다음 단계의 입력으로 자연스럽게 이어지도록 보장합니다. `execute_tool` 함수는 `tool_to_use` 문자열을 파싱하여 관련 Cog의 해당 함수(예: `finance_cog.execute_finnhub_search(...)`)를 동적으로 호출하는 '동적 도구 디스패치(Dynamic Tool Dispatch)'를 구현해야 합니다. 이는 LLM의 계획과 봇의 실제 기능 사이를 깔끔하고 확장 가능하게 연결합니다.

#### 실행 중 계획 수정 및 자가 교정 (고급)

ReAct 스타일 프롬프팅 프레임워크에서 영감을 받아, 도구 호출이 실패하거나 예상치 못한 데이터를 반환할 경우 실행기가 실패에 대한 '관찰(Observation)' 내용을 포함하여 계획 수립 LLM에게 다시 피드백을 보내는 고급 구현을 고려할 수 있습니다.[7] 그러면 LLM은 이 새로운 정보를 바탕으로 수정된 계획을 생성할 수 있습니다. 이 피드백 루프는 에이전트의 회복탄력성을 크게 향상시켜, 예측 불가능한 외부 환경 변화에 더 잘 대응하는 자가 교정 능력을 부여합니다.

### 1.3. 일관된 응답 생성을 위한 데이터 종합

실행 루프가 완료되면 `ai_handler.py`는 주식 시세, 뉴스 기사, 환율 등 다양한 데이터 객체들을 보유하게 됩니다. 이 마지막 단계는 수집된 데이터를 종합하여 사용자에게 일관성 있고 유용한 답변을 생성하는 과정입니다.

#### 종합을 위한 프롬프팅

`gemini-2.5-flash` 모델에 전달될 최종 프롬프트는 단순한 데이터 덤프가 되어서는 안 됩니다. 초기 계획 단계에서 생성된 `final_goal`, 사전에 필터링되고 구조화된 JSON 형식의 수집 데이터, 그리고 명확한 지침을 포함해야 합니다: *"다음 데이터를 기반으로 사용자의 목표 '[final\_goal]'에 대해 포괄적이고 사용자 친화적인 답변을 생성해 줘."*

이 접근 방식은 모델이 단순히 데이터를 나열하는 것을 넘어, 데이터 간의 관계를 이해하고 사용자의 원래 의도에 부합하는 통찰력 있는 답변을 생성하도록 유도합니다. 예를 들어, 주가와 관련 뉴스를 함께 제공하며 "최근 주가 변동은 다음과 같은 뉴스들의 영향을 받았을 수 있습니다"와 같은 분석적인 답변을 생성할 수 있습니다. `utils` 핸들러에서 이미 1차 필터링을 수행하지만, 종합 단계는 최종 답변 생성에 필요한 토큰 수를 최적화하기 위해 데이터를 요약하고 정제할 마지막 기회입니다. 예를 들어, 10개의 전체 뉴스 기사 본문 대신 헤드라인과 요약만 전달하여 비용 효율성을 높일 수 있습니다.

이 프로젝트에서 채택한 '계획 및 실행' 아키텍처는 네이티브 함수 호출의 단순한 대체재가 아니라, 의도적으로 선택된 매우 효과적인 설계입니다. 계획 수립에 경량 모델(`flash-lite`)을, 종합에 더 성능이 좋은 모델(`flash`)을 사용하는 것은 명백한 비용 최적화 전략입니다. 계획 생성과 실행을 분리함으로써, 시스템은 결정론적이고 디버깅이 용이한 Python 기반 실행기 내에서 복잡한 로직, 에러 재시도, 데이터 변환, API별 특수 처리 등을 완벽하게 제어할 수 있습니다. 선언적인 LLM 기반 계획기와 명령형 코드 기반 실행기를 결합한 이 하이브리드 접근 방식은, 완전 자율 LLM 에이전트의 예측 불가능성을 완화하면서도 자연어 이해와 추론이라는 핵심 강점을 활용하는, 상용 등급 AI 에이전트 구축의 강력한 패턴입니다. 따라서 이 아키텍처는 순수한 엔드-투-엔드 LLM 에이전트에 비해 견고성, 비용 효율성, 유지보수성 측면에서 명백한 우위를 가집니다.

## 섹션 2: API 통합 핸드북: 엔드포인트부터 구현까지

본 섹션은 보고서의 기술적 핵심으로, 5개 외부 API 각각에 대해 인증, 사용량 제한, 엔드포인트 명세, 데이터 구조, 모범 사례를 포함한 포괄적이고 구현 즉시 적용 가능한 가이드를 제공합니다. 이는 `utils` API 핸들러를 구축하는 개발자를 위한 기본 참조 문서 역할을 할 것입니다.

### 2.1. Riot Games API (League of Legends & Valorant)

#### 인증 및 키 관리

Riot Games API는 `X-Riot-Token` 헤더를 통해 API 키를 전달하는 방식을 사용합니다. 여기서 가장 중요한 운영상의 세부 사항은 **개발용 키(Development Key)가 24시간마다 만료된다**는 점입니다.[8, 9] 이는 `.env` 파일의 API 키를 매일 수동으로 갱신하거나, 이를 자동화하는 프로세스를 구축해야 함을 의미하며, 개발 과정에서 상당한 마찰을 유발할 수 있는 요소이므로 반드시 관리되어야 합니다.

#### 사용량 제한(Rate Limits) 심층 분석

실행 계획서에 명시된 "20회/1초, 100회/2분"은 '개인용 API 키(Personal API Key)'의 제한과 일치하며, 개발 단계에서 사용되는 '개발용 API 키' 역시 동일한 제한을 가집니다.[8, 10] 이 제한은 *지역(region)별로* 적용되므로, 여러 지역에 걸쳐 요청을 분산할 경우 약간의 유연성을 확보할 수 있습니다.[8, 11] 시스템이 자체적으로 설정한 안전 마진(15회/1초, 80회/2분)은 예상치 못한 트래픽 급증으로부터 시스템을 보호하는 건전한 엔지니어링 관행입니다.

**표 2.1: Riot API 개발용 키 사용량 제한**

| 제한 유형 | 공식 Riot Games 제한 | 마사몽 시스템 제한 (안전 마진 적용) | 비고 |
| :--- | :--- | :--- | :--- |
| 초당 요청 | 20회 | 15회 | 지역(Region)별로 독립적으로 적용됨 |
| 2분당 요청 | 100회 | 80회 | 지역(Region)별로 독립적으로 적용됨 |

#### 엔드포인트 워크플로우 및 데이터 구조

**1단계: 플레이어 식별 (`account-v1`)**
최신 워크플로우는 사용자의 Riot ID(예: "Hide on bush\#KR1")를 영구적인 고유 식별자인 `puuid`로 변환하는 것에서 시작합니다. `summoner-v4`의 소환사 이름 기반 검색은 폐기 예정(deprecated)이므로 사용을 지양해야 합니다.[12]

  * **엔드포인트:** `GET /riot/account/v1/accounts/by-riot-id/{gameName}/{tagLine}`
  * **요청:** 경로 매개변수로 `gameName`과 `tagLine`이 필요합니다.
  * **응답 (`AccountDto`):** `puuid` 필드를 포함한 단순 JSON 객체를 반환합니다. 이 78자 길이의 `puuid`는 이후 모든 플레이어 관련 조회의 핵심 키가 됩니다.[12]

**2단계: 경기 기록 목록 조회 (`match-v5`)**
획득한 `puuid`를 사용하여 최근 경기 ID 목록을 가져옵니다.

  * **엔드포인트:** `GET /lol/match/v5/matches/by-puuid/{puuid}/ids`
  * **요청:** `puuid`가 필수이며, `count`와 같은 선택적 매개변수를 통해 반환할 경기 수를 지정할 수 있습니다.[13]
  * **응답:** 경기 ID 문자열로 구성된 JSON 배열을 반환합니다 (예: \`\`).

**3단계: 상세 경기 데이터 조회 (`match-v5`)**
경기 ID(`matchId`)를 사용하여 해당 게임의 모든 상세 데이터를 조회합니다. 이 엔드포인트는 가장 풍부한 데이터를 제공합니다.

  * **엔드포인트:** `GET /lol/match/v5/matches/{matchId}`
  * **응답 (`MatchDto`):** 거대하고 중첩된 JSON 객체입니다. 가장 중요한 정보는 `info.participants` 배열 내에 있으며, 이 배열의 각 객체는 해당 경기에 참여한 10명의 플레이어 중 한 명의 데이터를 담고 있습니다.[12, 14, 15]

**표 2.2: `MatchDto.info.participants` 객체 내 주요 필드**

| 필드명 | 데이터 타입 | 설명 | 예시 |
| :--- | :--- | :--- | :--- |
| `puuid` | String | 플레이어의 고유 식별자 | `"dIWQhEO..."` |
| `summonerName` | String | 플레이어의 소환사 이름 | `"Hide on bush"` |
| `championName` | String | 플레이한 챔피언의 이름 | `"Faker"` |
| `win` | Boolean | 승리 여부 | `true` |
| `kills` | Integer | 킬 수 | `10` |
| `deaths` | Integer | 데스 수 | `2` |
| `assists` | Integer | 어시스트 수 | `8` |
| `totalDamageDealtToChampions` | Integer | 챔피언에게 가한 총 피해량 | `25430` |
| `goldEarned` | Integer | 획득한 총 골드 | `15200` |
| `visionScore` | Integer | 시야 점수 | `45` |
| `item0` - `item6` | Integer | 장착한 아이템의 ID | `3020` |

#### Valorant API: 현실적 제약사항

실행 계획서에서 정확히 지적한 바와 같이, Valorant 공식 API는 기능이 매우 제한적입니다. 공식 문서는 실시간 경기 데이터나 개인 전적 데이터를 제공하는 엔드포인트가 없음을 명확히 하고 있습니다.[16] 비공식 API가 존재하지만, 이는 안정성과 라이엇 게임즈의 정책 준수 측면에서 상용 시스템에 통합하기에 부적합합니다.[17, 18, 19] 따라서 Valorant 기능 구현은 valorant-api.com과 같은 커뮤니티 프로젝트에서 제공하는 요원, 맵, 무기 등 정적 게임 콘텐츠 정보를 제공하는 수준으로 엄격히 제한해야 합니다.[20] 이는 프로젝트의 리스크를 관리하는 중요한 결정입니다.

### 2.2. Finnhub API (글로벌 금융 데이터)

#### 인증 및 무료 플랜

Finnhub API는 `token`이라는 쿼리 매개변수를 통해 API 키를 전달하여 인증합니다.[21, 22, 23] 공식 가격 정책 페이지에 따르면 **무료 플랜의 사용량 제한은 분당 60회 호출**입니다.[24, 25] 시스템의 안전 마진인 분당 50회 설정은 이 제약을 준수하기 위한 합리적인 조치입니다.

#### 엔드포인트 1: 주식 시세 (`/quote`)

실시간 주가 정보를 제공하는 핵심 엔드포인트입니다.

  * **요청:** `GET /api/v1/quote?symbol={TICKER}&token={API_KEY}`
  * **응답:** 주요 실시간 지표를 포함하는 JSON 객체를 반환합니다.

**표 2.3: Finnhub `/quote` 응답 필드 정의**

| 필드명 | 설명 |
| :--- | :--- |
| `c` | 현재가 (Current price) |
| `d` | 가격 변동 (Change) |
| `dp` | 가격 변동률 (Percent change) |
| `h` | 당일 고가 (High price of the day) |
| `l` | 당일 저가 (Low price of the day) |
| `o` | 당일 시가 (Open price of the day) |
| `pc` | 전일 종가 (Previous close price) |
(출처: [26])

#### 엔드포인트 2: 기업 뉴스 (`/company-news`)

특정 종목에 대한 최신 뉴스를 검색합니다.

  * **요청:** `GET /api/v1/company-news?symbol={TICKER}&from=YYYY-MM-DD&to=YYYY-MM-DD&token={API_KEY}`
  * **응답:** 각 뉴스 기사를 나타내는 JSON 객체의 배열을 반환합니다. 답변 생성에 필수적인 필드는 `headline`, `summary`, `url`입니다.[22, 27] 무료 플랜에서는 최대 1년까지의 과거 뉴스만 조회 가능합니다.[24]

#### 구현 가이드

공식 Python 라이브러리인 `finnhub-python`을 사용하여 구현하는 것이 권장됩니다.[28, 29]

```python
# finnhub-python 라이브러리 사용 예시
import finnhub
import os

#.env 파일 등에서 API 키를 안전하게 로드
finnhub_client = finnhub.Client(api_key=os.environ.get("FINNHUB_API_KEY"))

# 'AAPL'의 현재 시세 조회
quote_data = finnhub_client.quote('AAPL')
print(quote_data)
```

### 2.3. Kakao Local API (지역 정보 검색)

#### 인증

`Authorization` 헤더에 `KakaoAK {REST_API_KEY}` 형식으로 REST API 키를 포함하여 요청을 인증합니다.[30, 31, 32]

#### 무료 쿼터 정책 정정

이 부분은 매우 중요한 수정 사항입니다. 기존 계획서에는 일일 300,000회로 명시되어 있으나, 카카오 개발자 공식 문서에 따르면 **'키워드로 장소 검색' API의 무료 쿼터는 일일 100,000회로 제한**됩니다.[33] 따라서 시스템의 Throttling 로직은 반드시 이 수정된 값에 맞춰 구현되어야 과금을 방지할 수 있습니다.

#### 엔드포인트: 키워드로 장소 검색 (`/v2/local/search/keyword.json`)

  * **요청:** `GET /v2/local/search/keyword.json?query={SEARCH_TERM}`
  * **응답:** 검색어와 일치하는 장소 목록을 담고 있는 `documents` 배열을 포함한 JSON 객체를 반환합니다.

**표 2.4: Kakao Local API `documents` 객체 필드 정의**

| 필드명 | 설명 |
| :--- | :--- |
| `place_name` | 장소명, 업체명 |
| `road_address_name` | 전체 도로명 주소 |
| `phone` | 전화번호 |
| `place_url` | 장소 상세 정보 URL (카카오맵) |
| `x` | 경도(Longitude) |
| `y` | 위도(Latitude) |
(출처: [30, 31])

### 2.4. 공공데이터포털 (KRX 국내 주식)

#### 인증

URL 인코딩된 서비스 키를 `serviceKey`라는 쿼리 매개변수로 전달하여 인증합니다. 이는 다수의 한국 정부 API에서 공통적으로 사용되는 방식입니다.[34]

#### 사용량 제한

계획서에 명시된 일일 10,000회 호출은 공공데이터포털의 표준 '일반' 트래픽 한도이며, 이는 타당한 가정입니다.[34, 35]

#### 엔드포인트: 주식 시세 정보 (`getStockPriceInfo`)

  * **요청:** `GET /1160100/service/GetStockSecuritiesInfoService/getStockPriceInfo?serviceKey={ENCODED_KEY}&itmsNm={ITEM_NAME}&resultType=json`
  * **필수 매개변수:** `serviceKey`, `itmsNm`(종목명, 예: "삼성전자"), 그리고 기본 응답 형식인 XML 대신 JSON을 받기 위한 `resultType=json`이 반드시 필요합니다.
  * **응답:** 데이터는 일반적으로 `response.body.items.item` 경로 아래에 일치하는 주식 정보 객체의 배열로 포함된 중첩 JSON 객체 형식으로 반환됩니다.

**표 2.5: KRX `getStockPriceInfo` 응답 필드 정의**

| 필드명 | 설명 |
| :--- | :--- |
| `itmsNm` | 종목명 (Item Name) |
| `clpr` | 종가 (Closing Price) |
| `vs` | 전일 대비 (Change from Previous Day) |
| `fltRt` | 등락률 (Fluctuation Rate) |
(출처: 사용자 계획서 및 일반적인 KRX API 구조)

### 2.5. 한국수출입은행 API (환율 정보)

#### 인증

`authkey`라는 쿼리 매개변수를 통해 인증키를 전달해야 합니다.[36, 37]

#### 사용량 제한

일일 1,000회 호출 제한은 여러 출처에서 확인되는 명확한 제약 조건입니다.[38] 계획서의 일일 900회 안전 마진 설정은 안정적인 운영을 위한 좋은 판단입니다.

#### 엔드포인트: 환율 조회 (`/exchangeJSON`)

  * **요청 URL 예시:** `https://www.koreaexim.go.kr/site/program/financial/exchangeJSON?authkey={API_KEY}&searchdate=YYYYMMDD&data=AP01`.[37] 여기서 `data=AP01`은 요청하는 데이터의 종류를 명시하는 필수 파라미터일 수 있습니다.
  * **응답:** 지정된 날짜의 원화(KRW) 대비 여러 국가 통화의 환율 정보를 담은 JSON 객체의 배열을 반환합니다.

**표 2.6: 한국수출입은행 `exchangeJSON` 응답 필드 정의**

| 필드명 | 설명 |
| :--- | :--- |
| `cur_unit` | 통화코드 (Currency Code, 예: "USD") |
| `deal_bas_r` | 매매기준율 (Basic Exchange Rate) |
| `cur_nm` | 국가/통화명 (Currency Name) |
(출처: 사용자 계획서 [39, 40])

## 섹션 3: 시스템 무결성 및 사용자 경험

본 섹션은 여러 API 호출의 집합을 세련되고 견고한 애플리케이션으로 변환하는 비기능적 요구사항과 사용자 대면 측면을 다룹니다.

### 3.1. 회복탄력적인 Throttling 및 캐싱 구현

#### 중앙 집중식 사용량 제한(Throttling)

각 API 호출 함수에 적용할 수 있는 Python 데코레이터 기반의 접근 방식을 제안합니다. 단일하고 설정 가능한 데코레이터를 `utils` 핸들러의 각 API 호출 함수에 적용함으로써, 중앙 설정 파일에서 해당 API의 특정 사용량 제한(예: Finnhub 60회/분, 수출입은행 1,000회/일)을 읽어와 호출 빈도를 관리할 수 있습니다. 이 방식은 코드 중복을 피하고, 일관된 정책을 강제하며, HTTP 429 (Too Many Requests) 오류를 사전에 방지하는 효과적인 방법입니다.

#### 지능형 캐싱 전략

계획서에서 플레이어의 `puuid`를 캐싱하는 것은 훌륭한 시작점입니다. 이를 확장하여, 변동성이 있지만 즉각적인 실시간성이 반드시 필요하지는 않은 데이터에 대해 시간 기반 캐시를 적용하는 것이 매우 효율적입니다. 예를 들어, 주식 시세는 60초, 환율 정보는 1시간 동안 캐싱할 수 있습니다. Python의 내장 라이브러리인 `functools.lru_cache`나 간단한 시간 기반 만료 로직을 가진 인-메모리 딕셔너리를 사용하여 이를 구현할 수 있습니다. 이 전략은 불필요한 API 호출을 극적으로 줄여 비용을 절감하고, 사용자에게 더 빠른 응답을 제공하며, API 사용량 제한을 초과할 위험을 낮춥니다.

### 3.2. 고급 오류 처리 및 풍부한 정보 표현

#### 세분화된 API 오류 처리

`utils` 핸들러의 오류 처리는 포괄적인 `try-except Exception` 구문을 넘어서야 합니다. `requests.exceptions.RequestException`과 같은 특정 예외를 포착하고 HTTP 상태 코드를 검사해야 합니다.

  * `429 (Too Many Requests)`: 지수 백오프(exponential backoff)를 적용한 후 재시도하는 메커니즘을 트리거해야 합니다.
  * `404 (Not Found)`: "정보를 찾을 수 없습니다"와 같은 명확한 메시지를 에이전트에게 반환하여, 사용자가 검색어를 수정하도록 유도할 수 있습니다.
  * `5xx (Server Error)`: "외부 서비스가 일시적으로 응답하지 않습니다"와 같은 메시지를 반환하여, 문제의 원인이 외부 서비스에 있음을 명확히 해야 합니다.
    이러한 세분화된 피드백은 에이전트가 더 나은 후속 답변을 형성하는 데 중요한 정보를 제공합니다.

#### 풍부한 Discord 임베드(Embeds) 설계

수집된 풍부한 데이터를 단순 텍스트로 응답하는 것은 정보의 가치를 떨어뜨립니다. Discord의 임베드 기능을 활용하여 각 주요 사용 사례에 맞는 시각적 템플릿을 설계해야 합니다.

  * **주식 시세 임베드:** 회사명, 티커, 현재가(상승/하락에 따라 녹색/적색으로 표시), 변동폭, 변동률을 명확히 표시합니다. 추가 정보 확인을 위해 Google Finance로 연결되는 버튼 컴포넌트를 제공합니다.
  * **게임 전적 임베드:** 플레이어의 챔피언 이미지, KDA, 승/패 상태, 핵심 아이템 빌드를 시각적으로 보여줍니다. OP.GG 프로필로 바로 이동할 수 있는 버튼을 포함하여 사용자 편의성을 극대화합니다.
  * **다단계 질문 임베드:** "애플 주식 원화 가격"과 같은 복합 질문에 대해, 임베드는 정보의 출처와 계산 과정을 투명하게 보여주어야 합니다. 예를 들어, "애플 (AAPL) 주가: $170.50", "USD/KRW 환율: ₩1,350.00", "최종 환산 가격: ₩230,175"와 같이 각 단계를 명확히 구분하여 제시합니다.

이러한 사용자 경험(UX) 설계는 단순한 미학적 개선이 아닙니다. 이는 에이전트가 수행한 복잡한 백그라운드 작업을 사용자에게 명확하고 가치 있는 형태로 전달하는 과정입니다. 잘 설계된 임베드는 정보의 가독성을 높이고, 에이전트의 응답에 대한 신뢰를 구축합니다. 또한 OP.GG나 Google Finance와 같은 권위 있는 외부 소스로 연결되는 버튼을 제공함으로써, 봇의 기능을 단순 정보 제공을 넘어 더 깊은 탐색을 위한 관문으로 확장시킵니다. 따라서 프레젠테이션 레이어(`cogs` 모듈)의 개발에 상당한 노력을 기울이는 것은 프로젝트 전체의 성공에 직접적인 영향을 미치는 핵심 요소입니다.

## 결론

'마사몽 AI 챗봇 2.4' 실행 계획은 기존 RAG 기반 시스템을 다단계 동적 도구 사용 에이전트로 전환하는 야심 차고 기술적으로 타당한 로드맵을 제시합니다. 본 보고서는 이 계획을 성공적으로 이행하기 위한 심층적인 기술 가이드와 전략적 제언을 제공했습니다.

**핵심 아키텍처의 강점:**
프로젝트의 '계획 및 실행' 아키텍처는 비용 효율성, 제어 가능성, 디버깅 용이성 측면에서 명백한 강점을 가집니다. 경량 모델로 계획을 수립하고, 결정론적인 Python 코드로 이를 실행하며, 최종적으로 강력한 모델로 결과를 종합하는 2단계 LLM 호출 분리 전략은 상용 수준의 AI 에이전트를 구축하는 데 있어 매우 효과적인 패턴입니다. 이 아키텍처는 LLM의 예측 불가능성을 통제하면서도 그 추론 능력을 최대한 활용하는 균형 잡힌 접근 방식입니다.

**API 통합의 주요 고려사항:**
5개 외부 API 각각에 대한 상세 분석을 통해, 개발팀은 이제 각 서비스의 인증 방식, 정확한 무료 사용량 제한, 핵심 엔드포인트의 데이터 구조에 대한 명확한 이해를 갖추게 되었습니다. 특히, Riot Games API의 24시간 키 만료 주기와 카카오맵 API의 실제 무료 쿼터(일일 100,000회)와 같은 운영상의 핵심 제약 조건들을 명확히 인지하고 시스템에 반영하는 것이 중요합니다. 각 API 핸들러는 본 보고서에서 제시된 데이터 필드 정의를 참조하여, 불필요한 데이터 파싱을 최소화하고 필수 정보만을 효율적으로 추출해야 합니다.

**성공을 위한 최종 권장사항:**

1.  **견고한 시스템 구현:** 중앙 집중식 Throttling 데코레이터와 지능형 캐싱 전략을 도입하여 시스템의 안정성과 효율성을 확보해야 합니다. 또한, HTTP 상태 코드에 기반한 세분화된 오류 처리 로직은 예외 상황에 대한 에이전트의 대응 능력을 크게 향상시킬 것입니다.
2.  **사용자 경험 최우선:** 에이전트의 지능은 최종적으로 사용자에게 어떻게 표현되는가에 따라 평가됩니다. Discord 임베드와 버튼을 적극적으로 활용하여 수집된 데이터를 시각적으로 풍부하고 직관적으로 전달하는 데 개발 리소스를 집중해야 합니다. 투명한 정보 제공과 외부 소스로의 손쉬운 연결은 사용자 신뢰와 만족도를 높이는 핵심 요소입니다.
3.  **지속적인 모니터링 및 개선:** API 제공사의 정책은 언제든지 변경될 수 있습니다. 각 API의 공식 문서를 주기적으로 확인하고, 시스템 내 API 호출 횟수와 오류율을 지속적으로 모니터링하여 변화에 신속하게 대응해야 합니다.
